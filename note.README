二、哪些类 / 场景用「值」
1️⃣ 用「值」= 我要一份“独立副本”

典型例子：

myvector& operator=(myvector other);

这意味着什么？

函数 拥有 other

生命周期清晰

构造阶段决定拷贝 or 移动

函数内部逻辑极简单

适合用值的场景

✅ 资源拥有者

vector

string

unique_ptr（移动时）

RAII 类型

✅ 小而便宜的类型

int

double

std::pair<int, int>

trivially copyable structs

一句判断口诀

当函数“需要一份属于自己的对象”时，用值

三、哪些用 const T&
2️⃣ const T& = “我只看，不改，不拿走”

这是 最常见、最安全、最稳妥 的参数形式。

void print(const myvector& v);
void foo(const std::string& s);

语义非常明确：

不拷贝

不修改

不延长生命周期

不接管资源

适合的场景

✅ 大对象
✅ 只读
✅ 工具函数
✅ 算法

为什么不是值？
void print(myvector v); // ❌


每次调用都拷贝

没任何收益

一句判断口诀

“我只是用一下你的东西” → const T&

四、哪些用 T&
3️⃣ T& = “我会改你，但你还是你的”
void normalize(myvector& v);
void sort(myvector& v);

语义：

不拥有

但会修改

调用方必须明确这一点

为什么不用返回值？

因为你在原地修改一个已有对象。

一句判断口诀

“我会动你，但不负责你的人生” → T&

五、哪些用 T&&（右值引用）
4️⃣ T&& = “我只接收将亡之物”
void set_data(myvector&& v);

表达的设计意图非常强：

你传进来的东西之后不能再用

我会偷资源

这是 destructive 操作

典型场景

构造函数

setter

工厂函数

容器插入（push_back(T&&)）

但注意 ⚠️

右值引用是“接口层语义工具”，
不是“到处都该用的高级语法”。


/////////////////////////////////////////////////////////////////////////////
const 约束的是“访问路径”，不是对象本身

这是理解这个问题的核心一句话：

const 修饰的是“你拿到的这个名字/视角”，
而不是“那个对象在宇宙中的真实身份”。


//////////////////////////////////////////////////////////////////////////////
1️⃣ 右值的生命周期

当一个对象是 右值（临时对象或 std::move 后的对象）时：

它会在表达式结束后立即被析构。

右值可以被安全地“偷走资源”（move），因为它本身即将消亡，不会再被用到。

所以右值提供了一个 优化机会：直接把内部资源指针交给新对象，而不是复制内存。

2️⃣ 你的移动构造函数
mystring(mystring&& other) noexcept
    : data_(other.data_),
      size_(other.size_),
      capacity_(other.capacity_) 
{
    other.data_ = new char[1]{'\0'};
    other.size_ = 0;
    other.capacity_ = 0;
}


分析：

data_ = other.data_

直接把右值的 data_ 指针“偷”过来。

新对象 this 拥有内存，右值对象不再管理原来的内存。

other.data_ = new char[1]{'\0'};

给右值对象分配一小块空内存，让它在析构时安全释放。

避免右值析构时指针变悬空。

size_ = other.size_ 和 capacity_ = other.capacity_

新对象继承原有数据大小和容量信息。

other.size_ = 0; other.capacity_ = 0;

右值对象变成空状态，析构安全。

3️⃣ 总结“函数体对右值的处理”

右值被“清空”：它原来的 data_ 被拿走，右值对象自己被重置成空对象。

右值析构安全：右值析构时只释放 new char[1]，不会 double free。

资源转移：原来右值的内存现在归新对象所有。

💡 可以把它想象成：

移动构造 = 偷资源 + 重置右值

拷贝构造 = 分配新资源 + 复制内容

//////////////////////////////////////////////////////////////////////////////
没有 '\0'，很多字符串函数（如 strlen、printf("%s")）就无法知道字符串哪里结束。

/////////////////////////////////////////////////////////////////////////////
小结
写法	作用	允许传入的对象类型
mystring(const mystring& other)	函数体不能改 other	const 对象 & 非 const 对象都可
mystring(mystring& other)	函数体可以改 other	只能传非 const 对象

💡 记忆法：

函数体看到的参数被 const 修饰 → 你不能在函数里修改它，同时 能安全接受 const 实参。